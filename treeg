#!/usr/bin/env ruby

#
# treeg searches filetrees for git repositories
# and prints a status summary for each
#
# /tri:dʒiː/
# Wolfgang Woehl 2023
# :wq 
#
AppName = File.basename( $0 )
AppVersion = 'v0.2023.12.17'
AppConfigFile = File.join( ENV[ 'HOME' ], ".#{ AppName }.conf" )
#
require 'date'
today = Date.today.to_s
require 'open3'
require 'etc'
homedir = Etc.getpwuid.dir
exclude_dirs = []
if RUBY_PLATFORM.match /darwin/
  exclude_dirs = [ File.join( homedir, 'Library' ), File.join( homedir, '.Trash' ) ]
end

git_dirs = []

config = {
  :configfile => AppConfigFile,
  :configfile_exists => false,
  :shellargs_present => false,
  :checkremote => true,
  :sortmodified => true,
  :showtag => 'last',
  :showtag_variants => [ 'dont', 'contains', 'last', 'annotated' ],
  :untrackeddirty => true,
  :stasheddirty => true,
  :explanation => true,
  :hideclean => false,
  :padded => false,
  :colored => true,
  :colors => ['black', 'red', 'green', 'brown', 'blue', 'magenta', 'cyan', 'gray'],
  :dirty => 'cyan',
  :detached => 'gray',
  :clean => 'green',
  :paths => [],
}

def parse_config( config )
  File.read( config[ :configfile ] ).split( "\n" ).each do |line|
    line = line.chomp.strip
    if line =~ /^#/ or line =~ /^\s*$/
      next
    end

    # brute force File.exist? through lines first (whitespace in paths)
    if File.exist?( File.expand_path( line ) )
      config[ :paths ] += [ File.expand_path( line) ]
    else
      option = line.split( /\s+/ )
      if option.size == 2
        key = option[0].to_sym
        value = option[1]
        if config.key? key
          case value
          when 'yes'
            config[ key ] = true
          when 'no'
            config[ key ] = false
          else
            if config[ :colors ].include? value
              config[ key ] = value
            elsif config[ :showtag_variants ].include? value
              config[ key ] = value
            end
          end
        end
      else
      end
    end
  end
  return config
end

def find_git_dirs( path, exclude_dirs )
  git_dirs = []
  exclude = ''
  exclude_dirs.each do |dir|
    exclude += "-not \\( -path #{ File.join( path, dir ) } -prune \\) "
  end
  find = "find #{ path } #{ exclude } -type d -name .git"
  git_dirs, err, status = Open3.capture3( find )
  git_dirs = git_dirs.split( "\n" )
  return git_dirs
end

def parse_branch( line )
  line = line.split( "\n" )[0]
  return [ '', false, 0, 0 ] if not line

  line = line[ 3.. ] if line.start_with? '## '

  match = line.match /^Initial commit on (.+)$/
  return [ match[1], false, 0, 0 ] unless match.nil?

  match = line.match /^(.+) \(no branch\)$/
  return [ match[1], true, 0, 0 ] unless match.nil?

  match = line.match /^(.+?)\.\.\./
  unless match.nil?
    branch = match[1]

    match = line.match /\[ahead (\d+), behind (\d+)\]$/
    return [ branch, false, match[2].to_i, match[1].to_i ] unless match.nil?

    match = line.match /\[ahead (\d+)\]$/
    return [ branch, false, 0, match[1].to_i ] unless match.nil?

    match = line.match /\[behind (\d+)\]$/
    return [ branch, false, match[1].to_i, 0 ] unless match.nil?

    return [ branch, false, 0, 0 ]
  end

  return [ line, false, 0, 0 ]
end # parse_branch

def parse_status( line )
  lines = line.split( "\n" ).map { |l| l.chomp }
  staged, unmerged, changed, untracked = 0, 0, 0, 0

  lines.each do |l|
    staged += 1 if l[0].include? 'MRC' or (l[0][0] == 'D' and l[1][0] != 'D') or (l[0][0] == 'A' and l[1][0] != 'A')
    unmerged += 1 if l[0][0] == 'U' or l[1][0] == 'U' or (l[0][0] == 'A' and l[1][0] == 'A') or (l[0][0] == 'D' and l[1][0] == 'D')
    changed += 1 if l[1][0] == 'M' or (l[1][0] == 'D' and l[0][0] != 'D')
    untracked += 1 if l[0][0] == '?'
  end

  return [ staged, unmerged, changed, untracked ]
end # parse_status

def build_summary( branch, dirty, detached, tag, behind, ahead, staged, unmerged, changed, untracked, stashed, untracked_dirty )
  segments = [ " #{ detached ? '✜detached (' + branch + ')' : '✜' + branch }" ]
  segments << " \u2605#{ tag }" if ! tag[0].nil? #tag[0].empty? # Black Star (U+2605)
  segments << " ↓#{ behind }" if behind.nonzero?
  segments << " ↑#{ ahead }" if ahead.nonzero?
  segments << " ●#{ staged }" if staged.nonzero?
  segments << " x#{ unmerged }" if unmerged.nonzero?
  segments << " ✚#{ changed }" if changed.nonzero?
  segments << " …#{ untracked }" if untracked.nonzero? and untracked_dirty
  segments << " ⚑#{ stashed.split( "\n" ).size } stash#{ stashed.split("\n").size != 1 ? 'es' : '' }" if ! stashed.empty?

  summary = segments.join( ' ' ) + ' '
  return summary
end # build_summary

class String
  def black;   "\e[30m#{self}\e[0m" end
  def red;     "\e[31m#{self}\e[0m" end
  def green;   "\e[32m#{self}\e[0m" end
  def brown;   "\e[33m#{self}\e[0m" end
  def blue;    "\e[34m#{self}\e[0m" end
  def magenta; "\e[35m#{self}\e[0m" end
  def cyan;    "\e[36m#{self}\e[0m" end
  def gray;    "\e[37m#{self}\e[0m" end

  def bold;    "\e[1m#{self}\e[22m" end
  def faint;   "\e[2m#{self}\e[22m" end
end

# main
#
# check for configfile
if File.exist? config[ :configfile ]
  config[ :configfile_exists ] = true
  config = parse_config( config )
end
# shellargs override paths provided in ~/.treeg.conf
unless ARGV.empty?
  config[ :shellargs_present ] = true
  paths = []
  ARGV.each do |arg|
    if File.exist?( arg ) and File.directory?( arg )
      paths << File.expand_path( arg )
    else
      puts "Skipping #{ arg.inspect } (not a directory)"
    end
  end
  config[ :paths ] = paths
end

# produce a sorted (a-z or by mtime) list of paths to potential git repositories
config[ :paths ].each do |path|
  git_dirs += find_git_dirs( path, exclude_dirs )
end

if config[ :sortmodified ]
  # brute force to find the youngest touch in each git_dir, then order git_dirs by that
  # ugh
  #
  mtime_map = {}
  git_dirs.each do |git_dir|
    # keeping this attempt to speed things up around - ~15% slower:
    #
    # find = "find #{ File.dirname( git_dir ) } -not \\( -path #{ git_dir } -prune \\) -type f -printf '%T@ %P\n' | sort -nr | awk '{print $2}'"
    # files, err, status = Open3.capture3( find )
    # most_recently_modified = files.gsub( /\n.*/, '' )
    # mtime_map[ git_dir ] = File.mtime File.join( File.dirname( git_dir ), most_recently_modified )

    find = "find #{ File.dirname( git_dir ) } -not \\( -path #{ git_dir } -prune \\) -type f"
    files, err, status = Open3.capture3( find )
    files = files.split( "\n" )
    most_recently_modified = ( files.sort_by { |file| File.mtime file } ).last
    mtime_map[ git_dir ] = File.mtime most_recently_modified
  end
  git_dirs = mtime_map.sort { |a, b| a[1] <=> b[1] }.map { |d| d[0] } # sort and get rid of the timestamp after
end

if config[ :padded ]
  maxlen_paths = git_dirs.map { |p| File.dirname( p ).gsub( homedir, '~' ).size }.max
end

not_a_git_dir_indices = []
git_dirs.each_with_index do |git_dir, git_dir_index|
  work_tree = File.dirname git_dir
  git_base = "git -c core.fsmonitor= --git-dir=#{ git_dir } --work-tree=#{ work_tree } "

  git_status_call = git_base + 'status --branch --porcelain'
  git_status, err, status = Open3.capture3( git_status_call )
  if err.include? 'fatal: not a git repository'
    not_a_git_dir_indices << git_dir_index
    puts "Skipping #{ git_dir } (not a git repository)"
    next
  end

  begin
    if config[ :checkremote ]
      day_fetch_head, err, status = Open3.capture3( "stat -c %y #{ File.join( git_dir, 'FETCH_HEAD' ) }" )
      day_fetch_head = day_fetch_head.gsub(/ .*\n/, '')
      if day_fetch_head == today
        checkremote_msg = "Already checked remote once today for #{ File.dirname( git_dir ).gsub( homedir, '~' ) }"
        printf "%s\r" % checkremote_msg
      else
        checkremote_msg = "Checking remote this once today for #{ File.dirname( git_dir ).gsub( homedir, '~' ) }..."
        printf "%s\r" % checkremote_msg
        git_checkremote_call = git_base + 'fetch'
        git_checkremote, err, status = Open3.capture3( git_checkremote_call )
      end
    end
  rescue Exception => e
    puts e.message
    puts "Could not check remote for #{ File.dirname( git_dir ).gsub( homedir, '~' ) }"
  end

  branch, detached, behind, ahead = parse_branch( git_status )

  next if branch.empty?

  if branch == 'HEAD'
    branch, err, status = Open3.capture3( git_base + 'rev-parse --short HEAD' )
    branch.chomp!
  end

  staged, unmerged, changed, untracked = parse_status( git_status )

  git_stashed_call = git_base + 'stash list --no-decorate'
  stashed, err, status = Open3.capture3( git_stashed_call )

  if
    staged.nonzero? or
    unmerged.nonzero? or
    changed.nonzero? or
    ( untracked.nonzero? and config[ :untrackeddirty ] ) or
    behind.nonzero? or
    ahead.nonzero? or
    ( stashed.size > 0 and config[ :stasheddirty ] )

    dirty = true
  else
    dirty = false
  end

  if config[ :hideclean ]
    if ! dirty and ! detached
      if config[ :checkremote ]
        printf "%s\r" % ( ' ' * checkremote_msg.size )
      end
      next
    end
  end

  if config[ :showtag ] == 'dont'
    tag, err = '', false
  elsif config[ :showtag ] == 'contains'
    tag, err, status = Open3.capture3( git_base + 'describe --contains' )
  elsif config[ :showtag ] == 'last'
    tag, err, status = Open3.capture3( git_base + 'describe --tags' )
  elsif config[ :showtag ] == 'annotated'
    tag, err, status = Open3.capture3( git_base + 'describe' )
  else
    tag, err, status = Open3.capture3( git_base + 'describe --tags --exact-match --abbrev=0' )
  end

  if err and ( err.include? 'error' or err.include? 'fatal' or err.include? 'Could not get sha1 for HEAD' )
    tag = ''
  end
  tag.chomp!

  summary = build_summary( branch, dirty, detached, tag, behind, ahead, staged, unmerged, changed, untracked, stashed, config[ :untrackeddirty ] )

  if config[ :padded ]
    work_tree = work_tree.gsub( homedir, '~' ).rjust( maxlen_paths )
  end
  if config[ :colored ]
    work_tree = File.join( File.dirname( work_tree ).faint, File.basename( work_tree ) )
    if dirty and ! detached
      output = "#{ work_tree }: #{ summary.send( config[ :dirty ] ) }"
    elsif dirty and detached
      output = "#{ work_tree }: #{ summary.send( config[ :detached ] ) }"
    elsif ! detached and ! dirty
      output = "#{ work_tree }: #{ summary.send( config[ :clean ] ) }"
    end
  else
    output = "#{ work_tree }: #{ summary }"
  end
  # clear checkremote_msg and print summary
  if config[ :checkremote ]
    printf "%s\r" % ( ' ' * checkremote_msg.size )
  end
  puts output

end # git_dirs.each
# prune git_dirs of impostors
not_a_git_dir_indices.each do |i|
  git_dirs.delete_at i
end

if git_dirs.size == 0 and not_a_git_dir_indices.size == 0
  puts "Use #{ config[ :configfile ] } to provide search path(s)" unless config[ :configfile_exists ]
  puts "Or run #{ AppName } with search path arguments" unless config[ :shellargs_present ]
  puts "Found 0 git repositories"
end

if config[ :explanation ] and git_dirs.size > 0
  puts "#{ AppName }:  ✜branch  \u2605tag  ↓behind  ↑ahead  ●staged  xunmerged  ✚changed  …untracked  ⚑stashed"
end

exit 0

